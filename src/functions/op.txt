0x01 live			Only arg is 4 bytes. Allows PROCESS to stay alive.
	live(char); No coding byte.	

0x02 ld				Loads (arg1) [any] into (arg2) [register]. Modify carry.
	load(*, reg);
	reg = * % IND;
	CARRY;

0x03 st				Take (arg1) [reg] and store into [reg | indi]
	store(reg, reg/ind);
	ADDRESS = PC + (arg2 % IND);
	ADDRESS_VALUE = arg1;

0x04 add			Take three [regs]. r3 = r1 + r2. Modify Carry.
	add(r1, r2, r3); 
	r3 = r1 + r2;
	CARRY;

0x05 sub			tale three [regs]. r3 = r1 - r2. Modify Carry.
	sub(r1, r2, r3);
	r3 = r1 - r2;
	CARRY;

0x06 and			Apply & to (arg1 & arg2) and store result in (arg3) [reg].
	and(*, *, reg);
	reg = * & *;
	CARRY;

0x07 or				or
	or(*, *, reg); 
	reg = * | *;
	CARRY;

0x08 xor			Exclusive OR operation. Modifies carry.
	xor(*, *, reg);
	reg = * &| *;
	CARRY;

0x09 zjmp			Takes an index and jumps to this address if the carry is 1.
	zjmp(index);
	if (carry == 1) {
		PC = addres(index);
	}

0x0a ldi			ld without index modifer.
	ldi(ind, ind, reg);
	address = (ind1 + ind2) ?% IND?;
	reg = ?reg_size?

0x0b sti			Stores value of a [reg] (arg1) into address of sum of (arg2, arg3) [ind | reg].
	sti(reg, ind/reg, ind/reg);
	ADDRESS = arg2 + arg3;
	ADDRESS_VALUE = arg1;

0x0c fork			No arg coding byte. Take an index. Create a process.
	fork(index);
	new_process = PC;
	new_PC = PC + index % IND;

0x0d lld			ld without % IND_MOD. Modify carry.
	load(*, reg);
	reg = *;
	CARRY;

0x0e lldi			Same as ldi. Does not apply modulo. Modify carry.
	lldi(ind, ind, reg);
	address = ind1 + ind2;
	reg = ?reg_size?


0x0f lfork			Same as fork but without modulo.
	lfork(index);
	new_process = PC;
	new_process = PC + index;

0x10 aff			
	CODING_BYTE EXISTS;
	aff(reg);
	putchar(reg % 256);


